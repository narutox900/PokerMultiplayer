// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: network.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_network_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_network_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_network_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_network_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_network_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_network_2eproto_metadata_getter(int index);
namespace network {
class ClientIdentity;
struct ClientIdentityDefaultTypeInternal;
extern ClientIdentityDefaultTypeInternal _ClientIdentity_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
struct CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class GameCreated;
struct GameCreatedDefaultTypeInternal;
extern GameCreatedDefaultTypeInternal _GameCreated_default_instance_;
class JoinRoomRequest;
struct JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
struct JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class LeaveRoomRequest;
struct LeaveRoomRequestDefaultTypeInternal;
extern LeaveRoomRequestDefaultTypeInternal _LeaveRoomRequest_default_instance_;
class LeaveRoomResponse;
struct LeaveRoomResponseDefaultTypeInternal;
extern LeaveRoomResponseDefaultTypeInternal _LeaveRoomResponse_default_instance_;
class QueryRoomInfoRequest;
struct QueryRoomInfoRequestDefaultTypeInternal;
extern QueryRoomInfoRequestDefaultTypeInternal _QueryRoomInfoRequest_default_instance_;
class QueryRoomInfoResponse;
struct QueryRoomInfoResponseDefaultTypeInternal;
extern QueryRoomInfoResponseDefaultTypeInternal _QueryRoomInfoResponse_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RoomInfoChanged;
struct RoomInfoChangedDefaultTypeInternal;
extern RoomInfoChangedDefaultTypeInternal _RoomInfoChanged_default_instance_;
class StartGameRequest;
struct StartGameRequestDefaultTypeInternal;
extern StartGameRequestDefaultTypeInternal _StartGameRequest_default_instance_;
}  // namespace network
PROTOBUF_NAMESPACE_OPEN
template<> ::network::ClientIdentity* Arena::CreateMaybeMessage<::network::ClientIdentity>(Arena*);
template<> ::network::ClientInfo* Arena::CreateMaybeMessage<::network::ClientInfo>(Arena*);
template<> ::network::CreateRoomRequest* Arena::CreateMaybeMessage<::network::CreateRoomRequest>(Arena*);
template<> ::network::CreateRoomResponse* Arena::CreateMaybeMessage<::network::CreateRoomResponse>(Arena*);
template<> ::network::GameCreated* Arena::CreateMaybeMessage<::network::GameCreated>(Arena*);
template<> ::network::JoinRoomRequest* Arena::CreateMaybeMessage<::network::JoinRoomRequest>(Arena*);
template<> ::network::JoinRoomResponse* Arena::CreateMaybeMessage<::network::JoinRoomResponse>(Arena*);
template<> ::network::LeaveRoomRequest* Arena::CreateMaybeMessage<::network::LeaveRoomRequest>(Arena*);
template<> ::network::LeaveRoomResponse* Arena::CreateMaybeMessage<::network::LeaveRoomResponse>(Arena*);
template<> ::network::QueryRoomInfoRequest* Arena::CreateMaybeMessage<::network::QueryRoomInfoRequest>(Arena*);
template<> ::network::QueryRoomInfoResponse* Arena::CreateMaybeMessage<::network::QueryRoomInfoResponse>(Arena*);
template<> ::network::RoomInfo* Arena::CreateMaybeMessage<::network::RoomInfo>(Arena*);
template<> ::network::RoomInfoChanged* Arena::CreateMaybeMessage<::network::RoomInfoChanged>(Arena*);
template<> ::network::StartGameRequest* Arena::CreateMaybeMessage<::network::StartGameRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace network {

// ===================================================================

class ClientInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  virtual ~ClientInfo();
  explicit constexpr ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return CreateMaybeMessage<ClientInfo>(nullptr);
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:network.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  virtual ~RoomInfo();
  explicit constexpr RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const final {
    return CreateMaybeMessage<RoomInfo>(nullptr);
  }

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 5,
    kIdFieldNumber = 1,
    kOwnerIdFieldNumber = 2,
    kIsFullFieldNumber = 3,
    kIsPlayingFieldNumber = 4,
  };
  // repeated .network.ClientInfo clients = 5;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::network::ClientInfo* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::ClientInfo >*
      mutable_clients();
  private:
  const ::network::ClientInfo& _internal_clients(int index) const;
  ::network::ClientInfo* _internal_add_clients();
  public:
  const ::network::ClientInfo& clients(int index) const;
  ::network::ClientInfo* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::ClientInfo >&
      clients() const;

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 owner_id = 2;
  void clear_owner_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 owner_id() const;
  void set_owner_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_owner_id() const;
  void _internal_set_owner_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_full = 3;
  void clear_is_full();
  bool is_full() const;
  void set_is_full(bool value);
  private:
  bool _internal_is_full() const;
  void _internal_set_is_full(bool value);
  public:

  // bool is_playing = 4;
  void clear_is_playing();
  bool is_playing() const;
  void set_is_playing(bool value);
  private:
  bool _internal_is_playing() const;
  void _internal_set_is_playing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::ClientInfo > clients_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 owner_id_;
  bool is_full_;
  bool is_playing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class ClientIdentity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.ClientIdentity) */ {
 public:
  inline ClientIdentity() : ClientIdentity(nullptr) {}
  virtual ~ClientIdentity();
  explicit constexpr ClientIdentity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientIdentity(const ClientIdentity& from);
  ClientIdentity(ClientIdentity&& from) noexcept
    : ClientIdentity() {
    *this = ::std::move(from);
  }

  inline ClientIdentity& operator=(const ClientIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientIdentity& operator=(ClientIdentity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientIdentity& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientIdentity* internal_default_instance() {
    return reinterpret_cast<const ClientIdentity*>(
               &_ClientIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientIdentity& a, ClientIdentity& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientIdentity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientIdentity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientIdentity* New() const final {
    return CreateMaybeMessage<ClientIdentity>(nullptr);
  }

  ClientIdentity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientIdentity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientIdentity& from);
  void MergeFrom(const ClientIdentity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientIdentity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.ClientIdentity";
  }
  protected:
  explicit ClientIdentity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // uint32 room_id = 1;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_room_id() const;
  void _internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 client_id = 2;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_client_id() const;
  void _internal_set_client_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:network.ClientIdentity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 room_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class QueryRoomInfoRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.QueryRoomInfoRequest) */ {
 public:
  inline QueryRoomInfoRequest() : QueryRoomInfoRequest(nullptr) {}
  virtual ~QueryRoomInfoRequest();
  explicit constexpr QueryRoomInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRoomInfoRequest(const QueryRoomInfoRequest& from);
  QueryRoomInfoRequest(QueryRoomInfoRequest&& from) noexcept
    : QueryRoomInfoRequest() {
    *this = ::std::move(from);
  }

  inline QueryRoomInfoRequest& operator=(const QueryRoomInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRoomInfoRequest& operator=(QueryRoomInfoRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryRoomInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRoomInfoRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRoomInfoRequest*>(
               &_QueryRoomInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QueryRoomInfoRequest& a, QueryRoomInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRoomInfoRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRoomInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryRoomInfoRequest* New() const final {
    return CreateMaybeMessage<QueryRoomInfoRequest>(nullptr);
  }

  QueryRoomInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryRoomInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryRoomInfoRequest& from);
  void MergeFrom(const QueryRoomInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRoomInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.QueryRoomInfoRequest";
  }
  protected:
  explicit QueryRoomInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotFullFieldNumber = 1,
  };
  // bool not_full = 1;
  void clear_not_full();
  bool not_full() const;
  void set_not_full(bool value);
  private:
  bool _internal_not_full() const;
  void _internal_set_not_full(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.QueryRoomInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool not_full_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class QueryRoomInfoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.QueryRoomInfoResponse) */ {
 public:
  inline QueryRoomInfoResponse() : QueryRoomInfoResponse(nullptr) {}
  virtual ~QueryRoomInfoResponse();
  explicit constexpr QueryRoomInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRoomInfoResponse(const QueryRoomInfoResponse& from);
  QueryRoomInfoResponse(QueryRoomInfoResponse&& from) noexcept
    : QueryRoomInfoResponse() {
    *this = ::std::move(from);
  }

  inline QueryRoomInfoResponse& operator=(const QueryRoomInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRoomInfoResponse& operator=(QueryRoomInfoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryRoomInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRoomInfoResponse* internal_default_instance() {
    return reinterpret_cast<const QueryRoomInfoResponse*>(
               &_QueryRoomInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QueryRoomInfoResponse& a, QueryRoomInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRoomInfoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRoomInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryRoomInfoResponse* New() const final {
    return CreateMaybeMessage<QueryRoomInfoResponse>(nullptr);
  }

  QueryRoomInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryRoomInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryRoomInfoResponse& from);
  void MergeFrom(const QueryRoomInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRoomInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.QueryRoomInfoResponse";
  }
  protected:
  explicit QueryRoomInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .network.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::network::RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::RoomInfo >*
      mutable_rooms();
  private:
  const ::network::RoomInfo& _internal_rooms(int index) const;
  ::network::RoomInfo* _internal_add_rooms();
  public:
  const ::network::RoomInfo& rooms(int index) const;
  ::network::RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:network.QueryRoomInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::RoomInfo > rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  virtual ~CreateRoomRequest();
  explicit constexpr CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomRequest* New() const final {
    return CreateMaybeMessage<CreateRoomRequest>(nullptr);
  }

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfoFieldNumber = 1,
  };
  // .network.ClientInfo client_info = 1;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::network::ClientInfo& client_info() const;
  ::network::ClientInfo* release_client_info();
  ::network::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::network::ClientInfo* client_info);
  private:
  const ::network::ClientInfo& _internal_client_info() const;
  ::network::ClientInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::network::ClientInfo* client_info);
  ::network::ClientInfo* unsafe_arena_release_client_info();

  // @@protoc_insertion_point(class_scope:network.CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::ClientInfo* client_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CreateRoomResponse) */ {
 public:
  inline CreateRoomResponse() : CreateRoomResponse(nullptr) {}
  virtual ~CreateRoomResponse();
  explicit constexpr CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomResponse(const CreateRoomResponse& from);
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomResponse* New() const final {
    return CreateMaybeMessage<CreateRoomResponse>(nullptr);
  }

  CreateRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRoomResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateRoomResponse& from);
  void MergeFrom(const CreateRoomResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CreateRoomResponse";
  }
  protected:
  explicit CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedIdentityFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .network.ClientIdentity assigned_identity = 2;
  bool has_assigned_identity() const;
  private:
  bool _internal_has_assigned_identity() const;
  public:
  void clear_assigned_identity();
  const ::network::ClientIdentity& assigned_identity() const;
  ::network::ClientIdentity* release_assigned_identity();
  ::network::ClientIdentity* mutable_assigned_identity();
  void set_allocated_assigned_identity(::network::ClientIdentity* assigned_identity);
  private:
  const ::network::ClientIdentity& _internal_assigned_identity() const;
  ::network::ClientIdentity* _internal_mutable_assigned_identity();
  public:
  void unsafe_arena_set_allocated_assigned_identity(
      ::network::ClientIdentity* assigned_identity);
  ::network::ClientIdentity* unsafe_arena_release_assigned_identity();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CreateRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::ClientIdentity* assigned_identity_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.JoinRoomRequest) */ {
 public:
  inline JoinRoomRequest() : JoinRoomRequest(nullptr) {}
  virtual ~JoinRoomRequest();
  explicit constexpr JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomRequest(const JoinRoomRequest& from);
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JoinRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomRequest* New() const final {
    return CreateMaybeMessage<JoinRoomRequest>(nullptr);
  }

  JoinRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinRoomRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JoinRoomRequest& from);
  void MergeFrom(const JoinRoomRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.JoinRoomRequest";
  }
  protected:
  explicit JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfoFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // .network.ClientInfo client_info = 1;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::network::ClientInfo& client_info() const;
  ::network::ClientInfo* release_client_info();
  ::network::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::network::ClientInfo* client_info);
  private:
  const ::network::ClientInfo& _internal_client_info() const;
  ::network::ClientInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::network::ClientInfo* client_info);
  ::network::ClientInfo* unsafe_arena_release_client_info();

  // uint32 room_id = 2;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_room_id() const;
  void _internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:network.JoinRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::ClientInfo* client_info_;
  ::PROTOBUF_NAMESPACE_ID::uint32 room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.JoinRoomResponse) */ {
 public:
  inline JoinRoomResponse() : JoinRoomResponse(nullptr) {}
  virtual ~JoinRoomResponse();
  explicit constexpr JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomResponse(const JoinRoomResponse& from);
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JoinRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomResponse* New() const final {
    return CreateMaybeMessage<JoinRoomResponse>(nullptr);
  }

  JoinRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinRoomResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JoinRoomResponse& from);
  void MergeFrom(const JoinRoomResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.JoinRoomResponse";
  }
  protected:
  explicit JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedIdentityFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .network.ClientIdentity assigned_identity = 2;
  bool has_assigned_identity() const;
  private:
  bool _internal_has_assigned_identity() const;
  public:
  void clear_assigned_identity();
  const ::network::ClientIdentity& assigned_identity() const;
  ::network::ClientIdentity* release_assigned_identity();
  ::network::ClientIdentity* mutable_assigned_identity();
  void set_allocated_assigned_identity(::network::ClientIdentity* assigned_identity);
  private:
  const ::network::ClientIdentity& _internal_assigned_identity() const;
  ::network::ClientIdentity* _internal_mutable_assigned_identity();
  public:
  void unsafe_arena_set_allocated_assigned_identity(
      ::network::ClientIdentity* assigned_identity);
  ::network::ClientIdentity* unsafe_arena_release_assigned_identity();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.JoinRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::ClientIdentity* assigned_identity_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.LeaveRoomRequest) */ {
 public:
  inline LeaveRoomRequest() : LeaveRoomRequest(nullptr) {}
  virtual ~LeaveRoomRequest();
  explicit constexpr LeaveRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomRequest(const LeaveRoomRequest& from);
  LeaveRoomRequest(LeaveRoomRequest&& from) noexcept
    : LeaveRoomRequest() {
    *this = ::std::move(from);
  }

  inline LeaveRoomRequest& operator=(const LeaveRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomRequest& operator=(LeaveRoomRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaveRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomRequest*>(
               &_LeaveRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LeaveRoomRequest& a, LeaveRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveRoomRequest* New() const final {
    return CreateMaybeMessage<LeaveRoomRequest>(nullptr);
  }

  LeaveRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveRoomRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaveRoomRequest& from);
  void MergeFrom(const LeaveRoomRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoomRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.LeaveRoomRequest";
  }
  protected:
  explicit LeaveRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdentityFieldNumber = 1,
  };
  // .network.ClientIdentity client_identity = 1;
  bool has_client_identity() const;
  private:
  bool _internal_has_client_identity() const;
  public:
  void clear_client_identity();
  const ::network::ClientIdentity& client_identity() const;
  ::network::ClientIdentity* release_client_identity();
  ::network::ClientIdentity* mutable_client_identity();
  void set_allocated_client_identity(::network::ClientIdentity* client_identity);
  private:
  const ::network::ClientIdentity& _internal_client_identity() const;
  ::network::ClientIdentity* _internal_mutable_client_identity();
  public:
  void unsafe_arena_set_allocated_client_identity(
      ::network::ClientIdentity* client_identity);
  ::network::ClientIdentity* unsafe_arena_release_client_identity();

  // @@protoc_insertion_point(class_scope:network.LeaveRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::ClientIdentity* client_identity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.LeaveRoomResponse) */ {
 public:
  inline LeaveRoomResponse() : LeaveRoomResponse(nullptr) {}
  virtual ~LeaveRoomResponse();
  explicit constexpr LeaveRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomResponse(const LeaveRoomResponse& from);
  LeaveRoomResponse(LeaveRoomResponse&& from) noexcept
    : LeaveRoomResponse() {
    *this = ::std::move(from);
  }

  inline LeaveRoomResponse& operator=(const LeaveRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomResponse& operator=(LeaveRoomResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaveRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomResponse* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomResponse*>(
               &_LeaveRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LeaveRoomResponse& a, LeaveRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveRoomResponse* New() const final {
    return CreateMaybeMessage<LeaveRoomResponse>(nullptr);
  }

  LeaveRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveRoomResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaveRoomResponse& from);
  void MergeFrom(const LeaveRoomResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoomResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.LeaveRoomResponse";
  }
  protected:
  explicit LeaveRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.LeaveRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class RoomInfoChanged PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.RoomInfoChanged) */ {
 public:
  inline RoomInfoChanged() : RoomInfoChanged(nullptr) {}
  virtual ~RoomInfoChanged();
  explicit constexpr RoomInfoChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfoChanged(const RoomInfoChanged& from);
  RoomInfoChanged(RoomInfoChanged&& from) noexcept
    : RoomInfoChanged() {
    *this = ::std::move(from);
  }

  inline RoomInfoChanged& operator=(const RoomInfoChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfoChanged& operator=(RoomInfoChanged&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomInfoChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfoChanged* internal_default_instance() {
    return reinterpret_cast<const RoomInfoChanged*>(
               &_RoomInfoChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RoomInfoChanged& a, RoomInfoChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfoChanged* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfoChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomInfoChanged* New() const final {
    return CreateMaybeMessage<RoomInfoChanged>(nullptr);
  }

  RoomInfoChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfoChanged>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomInfoChanged& from);
  void MergeFrom(const RoomInfoChanged& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfoChanged* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.RoomInfoChanged";
  }
  protected:
  explicit RoomInfoChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewRoomInfoFieldNumber = 1,
  };
  // .network.RoomInfo new_room_info = 1;
  bool has_new_room_info() const;
  private:
  bool _internal_has_new_room_info() const;
  public:
  void clear_new_room_info();
  const ::network::RoomInfo& new_room_info() const;
  ::network::RoomInfo* release_new_room_info();
  ::network::RoomInfo* mutable_new_room_info();
  void set_allocated_new_room_info(::network::RoomInfo* new_room_info);
  private:
  const ::network::RoomInfo& _internal_new_room_info() const;
  ::network::RoomInfo* _internal_mutable_new_room_info();
  public:
  void unsafe_arena_set_allocated_new_room_info(
      ::network::RoomInfo* new_room_info);
  ::network::RoomInfo* unsafe_arena_release_new_room_info();

  // @@protoc_insertion_point(class_scope:network.RoomInfoChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::network::RoomInfo* new_room_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class StartGameRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.StartGameRequest) */ {
 public:
  inline StartGameRequest() : StartGameRequest(nullptr) {}
  virtual ~StartGameRequest();
  explicit constexpr StartGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartGameRequest(const StartGameRequest& from);
  StartGameRequest(StartGameRequest&& from) noexcept
    : StartGameRequest() {
    *this = ::std::move(from);
  }

  inline StartGameRequest& operator=(const StartGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGameRequest& operator=(StartGameRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartGameRequest* internal_default_instance() {
    return reinterpret_cast<const StartGameRequest*>(
               &_StartGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StartGameRequest& a, StartGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGameRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartGameRequest* New() const final {
    return CreateMaybeMessage<StartGameRequest>(nullptr);
  }

  StartGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartGameRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartGameRequest& from);
  void MergeFrom(const StartGameRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGameRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.StartGameRequest";
  }
  protected:
  explicit StartGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.StartGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// -------------------------------------------------------------------

class GameCreated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.GameCreated) */ {
 public:
  inline GameCreated() : GameCreated(nullptr) {}
  virtual ~GameCreated();
  explicit constexpr GameCreated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameCreated(const GameCreated& from);
  GameCreated(GameCreated&& from) noexcept
    : GameCreated() {
    *this = ::std::move(from);
  }

  inline GameCreated& operator=(const GameCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameCreated& operator=(GameCreated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameCreated& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameCreated* internal_default_instance() {
    return reinterpret_cast<const GameCreated*>(
               &_GameCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GameCreated& a, GameCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(GameCreated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameCreated* New() const final {
    return CreateMaybeMessage<GameCreated>(nullptr);
  }

  GameCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameCreated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameCreated& from);
  void MergeFrom(const GameCreated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameCreated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.GameCreated";
  }
  protected:
  explicit GameCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_network_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // uint32 ip_address = 1;
  void clear_ip_address();
  ::PROTOBUF_NAMESPACE_ID::uint32 ip_address() const;
  void set_ip_address(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ip_address() const;
  void _internal_set_ip_address(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:network.GameCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ip_address_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_network_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientInfo

// uint32 id = 1;
inline void ClientInfo::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientInfo::id() const {
  // @@protoc_insertion_point(field_get:network.ClientInfo.id)
  return _internal_id();
}
inline void ClientInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void ClientInfo::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:network.ClientInfo.id)
}

// string name = 2;
inline void ClientInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ClientInfo::name() const {
  // @@protoc_insertion_point(field_get:network.ClientInfo.name)
  return _internal_name();
}
inline void ClientInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:network.ClientInfo.name)
}
inline std::string* ClientInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:network.ClientInfo.name)
  return _internal_mutable_name();
}
inline const std::string& ClientInfo::_internal_name() const {
  return name_.Get();
}
inline void ClientInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ClientInfo::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:network.ClientInfo.name)
}
inline void ClientInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:network.ClientInfo.name)
}
inline void ClientInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:network.ClientInfo.name)
}
inline std::string* ClientInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ClientInfo::release_name() {
  // @@protoc_insertion_point(field_release:network.ClientInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:network.ClientInfo.name)
}

// -------------------------------------------------------------------

// RoomInfo

// uint32 id = 1;
inline void RoomInfo::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoomInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoomInfo::id() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.id)
  return _internal_id();
}
inline void RoomInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void RoomInfo::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:network.RoomInfo.id)
}

// uint32 owner_id = 2;
inline void RoomInfo::clear_owner_id() {
  owner_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoomInfo::_internal_owner_id() const {
  return owner_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoomInfo::owner_id() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.owner_id)
  return _internal_owner_id();
}
inline void RoomInfo::_internal_set_owner_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  owner_id_ = value;
}
inline void RoomInfo::set_owner_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:network.RoomInfo.owner_id)
}

// bool is_full = 3;
inline void RoomInfo::clear_is_full() {
  is_full_ = false;
}
inline bool RoomInfo::_internal_is_full() const {
  return is_full_;
}
inline bool RoomInfo::is_full() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.is_full)
  return _internal_is_full();
}
inline void RoomInfo::_internal_set_is_full(bool value) {
  
  is_full_ = value;
}
inline void RoomInfo::set_is_full(bool value) {
  _internal_set_is_full(value);
  // @@protoc_insertion_point(field_set:network.RoomInfo.is_full)
}

// bool is_playing = 4;
inline void RoomInfo::clear_is_playing() {
  is_playing_ = false;
}
inline bool RoomInfo::_internal_is_playing() const {
  return is_playing_;
}
inline bool RoomInfo::is_playing() const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.is_playing)
  return _internal_is_playing();
}
inline void RoomInfo::_internal_set_is_playing(bool value) {
  
  is_playing_ = value;
}
inline void RoomInfo::set_is_playing(bool value) {
  _internal_set_is_playing(value);
  // @@protoc_insertion_point(field_set:network.RoomInfo.is_playing)
}

// repeated .network.ClientInfo clients = 5;
inline int RoomInfo::_internal_clients_size() const {
  return clients_.size();
}
inline int RoomInfo::clients_size() const {
  return _internal_clients_size();
}
inline void RoomInfo::clear_clients() {
  clients_.Clear();
}
inline ::network::ClientInfo* RoomInfo::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:network.RoomInfo.clients)
  return clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::ClientInfo >*
RoomInfo::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:network.RoomInfo.clients)
  return &clients_;
}
inline const ::network::ClientInfo& RoomInfo::_internal_clients(int index) const {
  return clients_.Get(index);
}
inline const ::network::ClientInfo& RoomInfo::clients(int index) const {
  // @@protoc_insertion_point(field_get:network.RoomInfo.clients)
  return _internal_clients(index);
}
inline ::network::ClientInfo* RoomInfo::_internal_add_clients() {
  return clients_.Add();
}
inline ::network::ClientInfo* RoomInfo::add_clients() {
  // @@protoc_insertion_point(field_add:network.RoomInfo.clients)
  return _internal_add_clients();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::ClientInfo >&
RoomInfo::clients() const {
  // @@protoc_insertion_point(field_list:network.RoomInfo.clients)
  return clients_;
}

// -------------------------------------------------------------------

// ClientIdentity

// uint32 room_id = 1;
inline void ClientIdentity::clear_room_id() {
  room_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientIdentity::_internal_room_id() const {
  return room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientIdentity::room_id() const {
  // @@protoc_insertion_point(field_get:network.ClientIdentity.room_id)
  return _internal_room_id();
}
inline void ClientIdentity::_internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  room_id_ = value;
}
inline void ClientIdentity::set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:network.ClientIdentity.room_id)
}

// uint32 client_id = 2;
inline void ClientIdentity::clear_client_id() {
  client_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientIdentity::_internal_client_id() const {
  return client_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientIdentity::client_id() const {
  // @@protoc_insertion_point(field_get:network.ClientIdentity.client_id)
  return _internal_client_id();
}
inline void ClientIdentity::_internal_set_client_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  client_id_ = value;
}
inline void ClientIdentity::set_client_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:network.ClientIdentity.client_id)
}

// -------------------------------------------------------------------

// QueryRoomInfoRequest

// bool not_full = 1;
inline void QueryRoomInfoRequest::clear_not_full() {
  not_full_ = false;
}
inline bool QueryRoomInfoRequest::_internal_not_full() const {
  return not_full_;
}
inline bool QueryRoomInfoRequest::not_full() const {
  // @@protoc_insertion_point(field_get:network.QueryRoomInfoRequest.not_full)
  return _internal_not_full();
}
inline void QueryRoomInfoRequest::_internal_set_not_full(bool value) {
  
  not_full_ = value;
}
inline void QueryRoomInfoRequest::set_not_full(bool value) {
  _internal_set_not_full(value);
  // @@protoc_insertion_point(field_set:network.QueryRoomInfoRequest.not_full)
}

// -------------------------------------------------------------------

// QueryRoomInfoResponse

// repeated .network.RoomInfo rooms = 1;
inline int QueryRoomInfoResponse::_internal_rooms_size() const {
  return rooms_.size();
}
inline int QueryRoomInfoResponse::rooms_size() const {
  return _internal_rooms_size();
}
inline void QueryRoomInfoResponse::clear_rooms() {
  rooms_.Clear();
}
inline ::network::RoomInfo* QueryRoomInfoResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:network.QueryRoomInfoResponse.rooms)
  return rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::RoomInfo >*
QueryRoomInfoResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:network.QueryRoomInfoResponse.rooms)
  return &rooms_;
}
inline const ::network::RoomInfo& QueryRoomInfoResponse::_internal_rooms(int index) const {
  return rooms_.Get(index);
}
inline const ::network::RoomInfo& QueryRoomInfoResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:network.QueryRoomInfoResponse.rooms)
  return _internal_rooms(index);
}
inline ::network::RoomInfo* QueryRoomInfoResponse::_internal_add_rooms() {
  return rooms_.Add();
}
inline ::network::RoomInfo* QueryRoomInfoResponse::add_rooms() {
  // @@protoc_insertion_point(field_add:network.QueryRoomInfoResponse.rooms)
  return _internal_add_rooms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::RoomInfo >&
QueryRoomInfoResponse::rooms() const {
  // @@protoc_insertion_point(field_list:network.QueryRoomInfoResponse.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// CreateRoomRequest

// .network.ClientInfo client_info = 1;
inline bool CreateRoomRequest::_internal_has_client_info() const {
  return this != internal_default_instance() && client_info_ != nullptr;
}
inline bool CreateRoomRequest::has_client_info() const {
  return _internal_has_client_info();
}
inline void CreateRoomRequest::clear_client_info() {
  if (GetArena() == nullptr && client_info_ != nullptr) {
    delete client_info_;
  }
  client_info_ = nullptr;
}
inline const ::network::ClientInfo& CreateRoomRequest::_internal_client_info() const {
  const ::network::ClientInfo* p = client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::ClientInfo&>(
      ::network::_ClientInfo_default_instance_);
}
inline const ::network::ClientInfo& CreateRoomRequest::client_info() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.client_info)
  return _internal_client_info();
}
inline void CreateRoomRequest::unsafe_arena_set_allocated_client_info(
    ::network::ClientInfo* client_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CreateRoomRequest.client_info)
}
inline ::network::ClientInfo* CreateRoomRequest::release_client_info() {
  
  ::network::ClientInfo* temp = client_info_;
  client_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::ClientInfo* CreateRoomRequest::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:network.CreateRoomRequest.client_info)
  
  ::network::ClientInfo* temp = client_info_;
  client_info_ = nullptr;
  return temp;
}
inline ::network::ClientInfo* CreateRoomRequest::_internal_mutable_client_info() {
  
  if (client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::ClientInfo>(GetArena());
    client_info_ = p;
  }
  return client_info_;
}
inline ::network::ClientInfo* CreateRoomRequest::mutable_client_info() {
  // @@protoc_insertion_point(field_mutable:network.CreateRoomRequest.client_info)
  return _internal_mutable_client_info();
}
inline void CreateRoomRequest::set_allocated_client_info(::network::ClientInfo* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete client_info_;
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(client_info);
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:network.CreateRoomRequest.client_info)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// bool success = 1;
inline void CreateRoomResponse::clear_success() {
  success_ = false;
}
inline bool CreateRoomResponse::_internal_success() const {
  return success_;
}
inline bool CreateRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomResponse.success)
  return _internal_success();
}
inline void CreateRoomResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void CreateRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:network.CreateRoomResponse.success)
}

// .network.ClientIdentity assigned_identity = 2;
inline bool CreateRoomResponse::_internal_has_assigned_identity() const {
  return this != internal_default_instance() && assigned_identity_ != nullptr;
}
inline bool CreateRoomResponse::has_assigned_identity() const {
  return _internal_has_assigned_identity();
}
inline void CreateRoomResponse::clear_assigned_identity() {
  if (GetArena() == nullptr && assigned_identity_ != nullptr) {
    delete assigned_identity_;
  }
  assigned_identity_ = nullptr;
}
inline const ::network::ClientIdentity& CreateRoomResponse::_internal_assigned_identity() const {
  const ::network::ClientIdentity* p = assigned_identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::ClientIdentity&>(
      ::network::_ClientIdentity_default_instance_);
}
inline const ::network::ClientIdentity& CreateRoomResponse::assigned_identity() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomResponse.assigned_identity)
  return _internal_assigned_identity();
}
inline void CreateRoomResponse::unsafe_arena_set_allocated_assigned_identity(
    ::network::ClientIdentity* assigned_identity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assigned_identity_);
  }
  assigned_identity_ = assigned_identity;
  if (assigned_identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CreateRoomResponse.assigned_identity)
}
inline ::network::ClientIdentity* CreateRoomResponse::release_assigned_identity() {
  
  ::network::ClientIdentity* temp = assigned_identity_;
  assigned_identity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::ClientIdentity* CreateRoomResponse::unsafe_arena_release_assigned_identity() {
  // @@protoc_insertion_point(field_release:network.CreateRoomResponse.assigned_identity)
  
  ::network::ClientIdentity* temp = assigned_identity_;
  assigned_identity_ = nullptr;
  return temp;
}
inline ::network::ClientIdentity* CreateRoomResponse::_internal_mutable_assigned_identity() {
  
  if (assigned_identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::ClientIdentity>(GetArena());
    assigned_identity_ = p;
  }
  return assigned_identity_;
}
inline ::network::ClientIdentity* CreateRoomResponse::mutable_assigned_identity() {
  // @@protoc_insertion_point(field_mutable:network.CreateRoomResponse.assigned_identity)
  return _internal_mutable_assigned_identity();
}
inline void CreateRoomResponse::set_allocated_assigned_identity(::network::ClientIdentity* assigned_identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete assigned_identity_;
  }
  if (assigned_identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(assigned_identity);
    if (message_arena != submessage_arena) {
      assigned_identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assigned_identity, submessage_arena);
    }
    
  } else {
    
  }
  assigned_identity_ = assigned_identity;
  // @@protoc_insertion_point(field_set_allocated:network.CreateRoomResponse.assigned_identity)
}

// -------------------------------------------------------------------

// JoinRoomRequest

// .network.ClientInfo client_info = 1;
inline bool JoinRoomRequest::_internal_has_client_info() const {
  return this != internal_default_instance() && client_info_ != nullptr;
}
inline bool JoinRoomRequest::has_client_info() const {
  return _internal_has_client_info();
}
inline void JoinRoomRequest::clear_client_info() {
  if (GetArena() == nullptr && client_info_ != nullptr) {
    delete client_info_;
  }
  client_info_ = nullptr;
}
inline const ::network::ClientInfo& JoinRoomRequest::_internal_client_info() const {
  const ::network::ClientInfo* p = client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::ClientInfo&>(
      ::network::_ClientInfo_default_instance_);
}
inline const ::network::ClientInfo& JoinRoomRequest::client_info() const {
  // @@protoc_insertion_point(field_get:network.JoinRoomRequest.client_info)
  return _internal_client_info();
}
inline void JoinRoomRequest::unsafe_arena_set_allocated_client_info(
    ::network::ClientInfo* client_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.JoinRoomRequest.client_info)
}
inline ::network::ClientInfo* JoinRoomRequest::release_client_info() {
  
  ::network::ClientInfo* temp = client_info_;
  client_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::ClientInfo* JoinRoomRequest::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:network.JoinRoomRequest.client_info)
  
  ::network::ClientInfo* temp = client_info_;
  client_info_ = nullptr;
  return temp;
}
inline ::network::ClientInfo* JoinRoomRequest::_internal_mutable_client_info() {
  
  if (client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::ClientInfo>(GetArena());
    client_info_ = p;
  }
  return client_info_;
}
inline ::network::ClientInfo* JoinRoomRequest::mutable_client_info() {
  // @@protoc_insertion_point(field_mutable:network.JoinRoomRequest.client_info)
  return _internal_mutable_client_info();
}
inline void JoinRoomRequest::set_allocated_client_info(::network::ClientInfo* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete client_info_;
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(client_info);
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:network.JoinRoomRequest.client_info)
}

// uint32 room_id = 2;
inline void JoinRoomRequest::clear_room_id() {
  room_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinRoomRequest::_internal_room_id() const {
  return room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JoinRoomRequest::room_id() const {
  // @@protoc_insertion_point(field_get:network.JoinRoomRequest.room_id)
  return _internal_room_id();
}
inline void JoinRoomRequest::_internal_set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  room_id_ = value;
}
inline void JoinRoomRequest::set_room_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:network.JoinRoomRequest.room_id)
}

// -------------------------------------------------------------------

// JoinRoomResponse

// bool success = 1;
inline void JoinRoomResponse::clear_success() {
  success_ = false;
}
inline bool JoinRoomResponse::_internal_success() const {
  return success_;
}
inline bool JoinRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:network.JoinRoomResponse.success)
  return _internal_success();
}
inline void JoinRoomResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void JoinRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:network.JoinRoomResponse.success)
}

// .network.ClientIdentity assigned_identity = 2;
inline bool JoinRoomResponse::_internal_has_assigned_identity() const {
  return this != internal_default_instance() && assigned_identity_ != nullptr;
}
inline bool JoinRoomResponse::has_assigned_identity() const {
  return _internal_has_assigned_identity();
}
inline void JoinRoomResponse::clear_assigned_identity() {
  if (GetArena() == nullptr && assigned_identity_ != nullptr) {
    delete assigned_identity_;
  }
  assigned_identity_ = nullptr;
}
inline const ::network::ClientIdentity& JoinRoomResponse::_internal_assigned_identity() const {
  const ::network::ClientIdentity* p = assigned_identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::ClientIdentity&>(
      ::network::_ClientIdentity_default_instance_);
}
inline const ::network::ClientIdentity& JoinRoomResponse::assigned_identity() const {
  // @@protoc_insertion_point(field_get:network.JoinRoomResponse.assigned_identity)
  return _internal_assigned_identity();
}
inline void JoinRoomResponse::unsafe_arena_set_allocated_assigned_identity(
    ::network::ClientIdentity* assigned_identity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assigned_identity_);
  }
  assigned_identity_ = assigned_identity;
  if (assigned_identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.JoinRoomResponse.assigned_identity)
}
inline ::network::ClientIdentity* JoinRoomResponse::release_assigned_identity() {
  
  ::network::ClientIdentity* temp = assigned_identity_;
  assigned_identity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::ClientIdentity* JoinRoomResponse::unsafe_arena_release_assigned_identity() {
  // @@protoc_insertion_point(field_release:network.JoinRoomResponse.assigned_identity)
  
  ::network::ClientIdentity* temp = assigned_identity_;
  assigned_identity_ = nullptr;
  return temp;
}
inline ::network::ClientIdentity* JoinRoomResponse::_internal_mutable_assigned_identity() {
  
  if (assigned_identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::ClientIdentity>(GetArena());
    assigned_identity_ = p;
  }
  return assigned_identity_;
}
inline ::network::ClientIdentity* JoinRoomResponse::mutable_assigned_identity() {
  // @@protoc_insertion_point(field_mutable:network.JoinRoomResponse.assigned_identity)
  return _internal_mutable_assigned_identity();
}
inline void JoinRoomResponse::set_allocated_assigned_identity(::network::ClientIdentity* assigned_identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete assigned_identity_;
  }
  if (assigned_identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(assigned_identity);
    if (message_arena != submessage_arena) {
      assigned_identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assigned_identity, submessage_arena);
    }
    
  } else {
    
  }
  assigned_identity_ = assigned_identity;
  // @@protoc_insertion_point(field_set_allocated:network.JoinRoomResponse.assigned_identity)
}

// -------------------------------------------------------------------

// LeaveRoomRequest

// .network.ClientIdentity client_identity = 1;
inline bool LeaveRoomRequest::_internal_has_client_identity() const {
  return this != internal_default_instance() && client_identity_ != nullptr;
}
inline bool LeaveRoomRequest::has_client_identity() const {
  return _internal_has_client_identity();
}
inline void LeaveRoomRequest::clear_client_identity() {
  if (GetArena() == nullptr && client_identity_ != nullptr) {
    delete client_identity_;
  }
  client_identity_ = nullptr;
}
inline const ::network::ClientIdentity& LeaveRoomRequest::_internal_client_identity() const {
  const ::network::ClientIdentity* p = client_identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::ClientIdentity&>(
      ::network::_ClientIdentity_default_instance_);
}
inline const ::network::ClientIdentity& LeaveRoomRequest::client_identity() const {
  // @@protoc_insertion_point(field_get:network.LeaveRoomRequest.client_identity)
  return _internal_client_identity();
}
inline void LeaveRoomRequest::unsafe_arena_set_allocated_client_identity(
    ::network::ClientIdentity* client_identity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_identity_);
  }
  client_identity_ = client_identity;
  if (client_identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.LeaveRoomRequest.client_identity)
}
inline ::network::ClientIdentity* LeaveRoomRequest::release_client_identity() {
  
  ::network::ClientIdentity* temp = client_identity_;
  client_identity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::ClientIdentity* LeaveRoomRequest::unsafe_arena_release_client_identity() {
  // @@protoc_insertion_point(field_release:network.LeaveRoomRequest.client_identity)
  
  ::network::ClientIdentity* temp = client_identity_;
  client_identity_ = nullptr;
  return temp;
}
inline ::network::ClientIdentity* LeaveRoomRequest::_internal_mutable_client_identity() {
  
  if (client_identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::ClientIdentity>(GetArena());
    client_identity_ = p;
  }
  return client_identity_;
}
inline ::network::ClientIdentity* LeaveRoomRequest::mutable_client_identity() {
  // @@protoc_insertion_point(field_mutable:network.LeaveRoomRequest.client_identity)
  return _internal_mutable_client_identity();
}
inline void LeaveRoomRequest::set_allocated_client_identity(::network::ClientIdentity* client_identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete client_identity_;
  }
  if (client_identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(client_identity);
    if (message_arena != submessage_arena) {
      client_identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_identity, submessage_arena);
    }
    
  } else {
    
  }
  client_identity_ = client_identity;
  // @@protoc_insertion_point(field_set_allocated:network.LeaveRoomRequest.client_identity)
}

// -------------------------------------------------------------------

// LeaveRoomResponse

// bool success = 1;
inline void LeaveRoomResponse::clear_success() {
  success_ = false;
}
inline bool LeaveRoomResponse::_internal_success() const {
  return success_;
}
inline bool LeaveRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:network.LeaveRoomResponse.success)
  return _internal_success();
}
inline void LeaveRoomResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LeaveRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:network.LeaveRoomResponse.success)
}

// -------------------------------------------------------------------

// RoomInfoChanged

// .network.RoomInfo new_room_info = 1;
inline bool RoomInfoChanged::_internal_has_new_room_info() const {
  return this != internal_default_instance() && new_room_info_ != nullptr;
}
inline bool RoomInfoChanged::has_new_room_info() const {
  return _internal_has_new_room_info();
}
inline void RoomInfoChanged::clear_new_room_info() {
  if (GetArena() == nullptr && new_room_info_ != nullptr) {
    delete new_room_info_;
  }
  new_room_info_ = nullptr;
}
inline const ::network::RoomInfo& RoomInfoChanged::_internal_new_room_info() const {
  const ::network::RoomInfo* p = new_room_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::RoomInfo&>(
      ::network::_RoomInfo_default_instance_);
}
inline const ::network::RoomInfo& RoomInfoChanged::new_room_info() const {
  // @@protoc_insertion_point(field_get:network.RoomInfoChanged.new_room_info)
  return _internal_new_room_info();
}
inline void RoomInfoChanged::unsafe_arena_set_allocated_new_room_info(
    ::network::RoomInfo* new_room_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_room_info_);
  }
  new_room_info_ = new_room_info;
  if (new_room_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.RoomInfoChanged.new_room_info)
}
inline ::network::RoomInfo* RoomInfoChanged::release_new_room_info() {
  
  ::network::RoomInfo* temp = new_room_info_;
  new_room_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::network::RoomInfo* RoomInfoChanged::unsafe_arena_release_new_room_info() {
  // @@protoc_insertion_point(field_release:network.RoomInfoChanged.new_room_info)
  
  ::network::RoomInfo* temp = new_room_info_;
  new_room_info_ = nullptr;
  return temp;
}
inline ::network::RoomInfo* RoomInfoChanged::_internal_mutable_new_room_info() {
  
  if (new_room_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::RoomInfo>(GetArena());
    new_room_info_ = p;
  }
  return new_room_info_;
}
inline ::network::RoomInfo* RoomInfoChanged::mutable_new_room_info() {
  // @@protoc_insertion_point(field_mutable:network.RoomInfoChanged.new_room_info)
  return _internal_mutable_new_room_info();
}
inline void RoomInfoChanged::set_allocated_new_room_info(::network::RoomInfo* new_room_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_room_info_;
  }
  if (new_room_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_room_info);
    if (message_arena != submessage_arena) {
      new_room_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_room_info, submessage_arena);
    }
    
  } else {
    
  }
  new_room_info_ = new_room_info;
  // @@protoc_insertion_point(field_set_allocated:network.RoomInfoChanged.new_room_info)
}

// -------------------------------------------------------------------

// StartGameRequest

// bool success = 1;
inline void StartGameRequest::clear_success() {
  success_ = false;
}
inline bool StartGameRequest::_internal_success() const {
  return success_;
}
inline bool StartGameRequest::success() const {
  // @@protoc_insertion_point(field_get:network.StartGameRequest.success)
  return _internal_success();
}
inline void StartGameRequest::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void StartGameRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:network.StartGameRequest.success)
}

// -------------------------------------------------------------------

// GameCreated

// uint32 ip_address = 1;
inline void GameCreated::clear_ip_address() {
  ip_address_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameCreated::_internal_ip_address() const {
  return ip_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameCreated::ip_address() const {
  // @@protoc_insertion_point(field_get:network.GameCreated.ip_address)
  return _internal_ip_address();
}
inline void GameCreated::_internal_set_ip_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ip_address_ = value;
}
inline void GameCreated::set_ip_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ip_address(value);
  // @@protoc_insertion_point(field_set:network.GameCreated.ip_address)
}

// uint32 port = 2;
inline void GameCreated::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameCreated::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameCreated::port() const {
  // @@protoc_insertion_point(field_get:network.GameCreated.port)
  return _internal_port();
}
inline void GameCreated::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void GameCreated::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:network.GameCreated.port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_network_2eproto
